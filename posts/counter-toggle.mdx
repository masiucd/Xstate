---
title: Counter Toggle
slug: counter-toggle
spoiler: Counter toggle machine, cool example
author: "Marcell Ciszek"
date: "2021-05-01"
---

### A counter machine mixed with a toggle

Here we got a Accordian produced via `X-state`. We can toggle the machine but also choose if we want
to use the counter machine o rhe timer `machine`.

Here is the code for the `Accordian`

<AccordionWrapper />

### Toggle Machine

```tsx
import {assign, createMachine} from "xstate"
interface CountCtx {
  count: number
}

type CountMachineEvents =
  | {type: "ON"}
  | {type: "OFF"}
  | {type: "INCREMENT"}
  | {type: "DECREMENT"}
  | {type: "RESET"}

const counterMachine = createMachine<CountCtx, CountMachineEvents>(
  {
    id: "counterMachine",
    initial: "inactive",
    context: {
      count: 0,
    },
    states: {
      inactive: {
        entry: ["resetCount"],
        on: {
          ON: {
            target: "active",
          },
        },
      },
      active: {
        on: {
          OFF: {
            target: "inactive",
          },
          INCREMENT: {
            actions: ["incrementCount"],
          },
          DECREMENT: {
            actions: ["decrementCount"],
          },
          RESET: {
            actions: ["resetCount"],
          },
        },
      },
    },
  },
  {
    actions: {
      incrementCount: assign({
        count: (ctx: CountCtx) => ctx.count + 1,
      }),
      decrementCount: assign({
        count: (ctx: CountCtx) => ctx.count - 1,
      }),
      resetCount: assign({
        count: 0,
      }),
    },
  }
)

export default counterMachine
```

### And the Counter Machine

```ts
import {assign, createMachine} from "xstate"
interface TimerContext {
  duration: number
  elapsed: number
  interval: number
}

type TimerEvents =
  | {type: "TOGGLE"}
  | {type: "TICK"}
  | {type: "ADD_MINUTE"}
  | {type: "ADD_HOUR"}
  | {type: "ADD_SECONDS"}
  | {type: "RESET"}

const timerExpired = (ctx: TimerContext) => ctx.elapsed >= ctx.duration

const timeMachine = createMachine<TimerContext, TimerEvents>(
  {
    id: "timeMachine",
    initial: "idle",
    context: {
      duration: 5,
      elapsed: 0,
      interval: 0.1,
    },
    states: {
      idle: {
        entry: ["resetTimer"],
        on: {
          TOGGLE: {
            target: "running",
          },
        },
      },
      running: {
        always: {
          target: "expired",
          cond: timerExpired,
        },
        on: {
          TICK: {
            actions: ["tick"],
          },
          TOGGLE: {
            target: "paused",
          },
          ADD_HOUR: {
            actions: "addHour",
          },
          ADD_MINUTE: {
            actions: "addMinute",
          },
          ADD_SECONDS: {
            actions: "addSeconds",
          },
        },
      },
      paused: {
        on: {
          TOGGLE: {
            target: "running",
          },
          RESET: {
            target: "idle",
          },
        },
      },
      expired: {
        always: {
          target: "idle",
        },
      },
    },
  },
  {
    actions: {
      resetTimer: assign({
        duration: 5,
        elapsed: 0,
        interval: 0.1,
      }),
      tick: assign({
        elapsed: ctx => ctx.elapsed + ctx.interval,
      }),
      addMinute: assign({
        duration: ctx => ctx.duration + 60,
      }),
      addHour: assign({
        duration: ctx => ctx.duration + 3600,
      }),
      addSeconds: assign({
        duration: ctx => ctx.duration + 30,
      }),
    },
  }
)

export default timeMachine
```
